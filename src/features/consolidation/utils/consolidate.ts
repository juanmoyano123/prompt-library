import { Project, Prompt, ConsolidationResult, ProjectStatistics, ExecutionHistory } from '@/types';
import { MODEL_CATALOG } from '@/data/modelCatalog';

/**
 * Consolida un proyecto completo con todos sus prompts y estadísticas
 */
export function consolidateProject(
  project: Project,
  prompts: Prompt[]
): ConsolidationResult {
  // Filtrar solo los prompts del proyecto
  const projectPrompts = prompts.filter((p) =>
    project.promptIds.includes(p.id)
  );

  // Recopilar todo el historial de ejecuciones
  const allExecutionHistory: ExecutionHistory[] = [];
  projectPrompts.forEach((prompt) => {
    if (prompt.executionHistory) {
      allExecutionHistory.push(...prompt.executionHistory);
    }
  });

  // Calcular estadísticas del proyecto
  const statistics = calculateProjectStatistics(project, projectPrompts, allExecutionHistory);

  return {
    project,
    prompts: projectPrompts,
    executionHistory: allExecutionHistory,
    statistics,
    generatedAt: new Date(),
  };
}

/**
 * Calcula estadísticas detalladas del proyecto
 */
function calculateProjectStatistics(
  project: Project,
  prompts: Prompt[],
  executions: ExecutionHistory[]
): ProjectStatistics {
  const totalPrompts = prompts.length;
  const totalVersions = prompts.reduce((sum, p) => sum + (p.versions?.length || 0), 0);
  const totalExecutions = executions.length;
  const totalTokensUsed = executions.reduce((sum, exec) => sum + exec.tokensUsed, 0);
  const totalCost = executions.reduce((sum, exec) => sum + exec.estimatedCost, 0);

  // Prompt más usado
  const mostUsedPrompt = prompts.reduce((prev, current) =>
    current.usageCount > (prev?.usageCount || 0) ? current : prev
  , undefined as Prompt | undefined);

  // Ejecuciones y costos por modelo
  const executionsByModel: Record<string, number> = {};
  const costByModel: Record<string, number> = {};

  executions.forEach((exec) => {
    executionsByModel[exec.model] = (executionsByModel[exec.model] || 0) + 1;
    costByModel[exec.model] = (costByModel[exec.model] || 0) + exec.estimatedCost;
  });

  // Modelo más caro
  const mostExpensiveModel = Object.entries(costByModel).reduce(
    (prev, [model, cost]) =>
      cost > (prev?.cost || 0) ? { model, cost } : prev,
    { model: '', cost: 0 }
  ).model;

  const averageTokensPerExecution =
    totalExecutions > 0 ? totalTokensUsed / totalExecutions : 0;

  return {
    totalPrompts,
    totalVersions,
    totalExecutions,
    totalTokensUsed,
    totalCost,
    mostUsedPrompt,
    mostExpensiveModel: mostExpensiveModel || undefined,
    averageTokensPerExecution,
    executionsByModel,
    costByModel,
  };
}

/**
 * Genera un resumen ejecutivo del proyecto
 */
export function generateExecutiveSummary(result: ConsolidationResult): string {
  const { project, statistics } = result;

  const summary = `
# ${project.name} - Executive Summary

**Generated:** ${new Date(result.generatedAt).toLocaleString()}

## Overview
${project.description || 'No description provided'}

## Key Metrics

- **Total Prompts:** ${statistics.totalPrompts}
- **Total Versions:** ${statistics.totalVersions}
- **Total Executions:** ${statistics.totalExecutions}
- **Total Tokens Used:** ${statistics.totalTokensUsed.toLocaleString()}
- **Total Cost:** $${statistics.totalCost.toFixed(4)}

## Performance

- **Average Tokens per Execution:** ${Math.round(statistics.averageTokensPerExecution).toLocaleString()}
- **Most Used Prompt:** ${statistics.mostUsedPrompt?.title || 'N/A'}
- **Most Expensive Model:** ${statistics.mostExpensiveModel || 'N/A'}

## Model Usage

${Object.entries(statistics.executionsByModel)
  .map(([model, count]) => `- **${model}:** ${count} executions ($${(statistics.costByModel[model] || 0).toFixed(4)})`)
  .join('\n')}

## Project Settings

- **Default Model:** ${project.settings.defaultModel}
- **Default Token Limit:** ${project.settings.defaultTokenLimit.toLocaleString()}
- **Temperature:** ${project.settings.temperature || 0.7}
- **Cost per 1K Tokens:** $${project.settings.estimatedCostPerToken}

---
*Generated by Prompt Library - AI Prompt Management System*
`;

  return summary.trim();
}

/**
 * Genera un informe detallado por prompt
 */
export function generateDetailedReport(result: ConsolidationResult): string {
  const { prompts, statistics } = result;

  let report = generateExecutiveSummary(result);

  report += '\n\n## Detailed Prompt Analysis\n\n';

  prompts.forEach((prompt, index) => {
    const execCount = prompt.executionHistory?.length || 0;
    const totalTokens = prompt.executionHistory?.reduce((sum, exec) => sum + exec.tokensUsed, 0) || 0;
    const totalCost = prompt.executionHistory?.reduce((sum, exec) => sum + exec.estimatedCost, 0) || 0;

    report += `
### ${index + 1}. ${prompt.title}

**Category:** ${prompt.category}
**Tags:** ${prompt.tags.join(', ') || 'None'}
**Created:** ${new Date(prompt.createdAt).toLocaleDateString()}
**Last Updated:** ${new Date(prompt.updatedAt).toLocaleDateString()}

**Usage Stats:**
- Times Used: ${prompt.usageCount}
- Executions: ${execCount}
- Total Tokens: ${totalTokens.toLocaleString()}
- Total Cost: $${totalCost.toFixed(4)}
- Versions: ${prompt.versions?.length || 0}
- Favorite: ${prompt.isFavorite ? 'Yes' : 'No'}

**Prompt Content:**
\`\`\`
${prompt.content}
\`\`\`

${prompt.description ? `**Description:** ${prompt.description}\n` : ''}
---
`;
  });

  return report;
}
